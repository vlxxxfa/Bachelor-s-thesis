\chapter{Realisierbarkeit}
%\chapter{\colorbox{yellow}{Realisierbarkeit}}

\section{Implementierung}

Im folgenden Kapitel wird anhand von Beispielen gezeigt, wie die vorgeschlagene Architektur in einem Prototyp mit dem Einsatz der besprochenen Frameworks umgesetzt wird.

\subsection{Datenbank}
%\subsection{\colorbox{yellow}{Datenbank}}

Der Backend-Teil des Prototyps wird in Java implementiert. Um alle verfügbaren \mongo-Operationen in Java nutzen zu können, muss zuerst der entsprechende Treiber geholt werden.

Der Java \mongo-Treiber kann beispielsweise durch Maven-Konfigurationsdatei \texttt{pom.xml} als Abhängigkeit deklariert werden, um benötigte Bibliotheken automatisch herunterzuladen. In Fall des Prototyps wird der MongoDB Java Treiber benötigt.

\begin{listingsboxJava}[label={lst:pom}]{myxml}{MongoDB Java Treiber als Maven Dependency, Version 3.4.2}
	<!-- Mongo Java Driver -->
	<dependency>
		<groupId>org.mongodb</groupId>
		<artifactId>mongo-java-driver</artifactId>
		<version>3.4.2</version>
	</dependency>
\end{listingsboxJava}

Für die Kommunikation mit einer Datenbank und ihren \textit{Collections}, die auf einem einzigen Server abgelegt sind, reicht in Java-Klasse Folgendes zu deklarieren:
\begin{listingsboxJava}[label={lst:conn}]{myJava}{Verbindungsaufbau mit einem Server}
public static void main(String[] args) {

	MongoClient mongoClient = new MongoClient("localhost", 27017);
	MongoDatabase db = mongoClient.getDatabase("qwertz");
	MongoCollection<Document> collectionOfUsers = db.getCollection("users");
        
        // weitere CRUD-Operationen mit der ausgewählten Collection
}
\end{listingsboxJava}

Falls die Daten auf einem einzigen Server abgelegt werden, kann inzwischen beim Serverausfall vorkommen, dass die Daten für eine ungewisse Zeit gar nicht verfügbar sind. Um die Verfügbarkeit der Daten auch beim Serverausfall zu garantieren, wird in dem Prototyp eine Replikationsgruppe mit insgesamt  3-Servern erzeugt.

%\subsubsection{\colorbox{yellow}{Replikation (Replication)}}
\subsubsection{Replikation (Replication)}

Eine Replikatioinsgruppe anzulegen, ist es nur über die sog. \textit{Mongo Shell} auf der Kommandozeile möglich. Um die Replikationsgruppe effizienter erzeugen zu können, wird ein Skript geschrieben, (\textbf{Anhang \ref{anhang}, Listing \ref{lst:createReplSet}}). Das Skript legt neue Ordner an, welche unter Anderem die \textit{logs}-Dateien jeweiliger Server enthalten werden. Des Weiteren wird eine Gruppe erzeugt, Gruppenname definiert und die entsprechenden Server zu der Gruppe zugeordnet.

%\begin{listingsboxShell}[label={lst:scriptForCreateOfRep}]{myshell}{Skript zum Erstellen einer Replikationsgruppe}
%#create_replica_set.sh
%#!/usr/bin/env bash
%
%mkdir -p /data/rs1 /data/rs2 /data/rs3
%
%#Start von drei lokalen mongod-Instanzen als Replikationsgruppe
%
%mongod --replSet m101 --logpath "1.log" --dbpath /data/rs1 --port 27017
%--oplogSize 64 --fork --smallfiles
%mongod --replSet m101 --logpath "2.log" --dbpath /data/rs2 --port 27018
%--oplogSize 64 --smallfiles --fork
%mongod --replSet m101 --logpath "3.log" --dbpath /data/rs3 --port 27019
%--oplogSize 64 --smallfiles --fork
%\end{listingsboxShell}

%Das Skript mit dem Inhalt aus Listing \ref{lst:scriptForCreateOfRep} wird folgendermaßen ausgeführt:
%
%\begin{listingsboxShell}[label={lst:runOfscriptForCreateOfRep}]{myshell}{Erstellen einer Replikationsgruppe anhand eines Skriptes}
%vlfa:scripts vlfa$ bash < create_replica_set.sh
%\end{listingsboxShell}

%Damit ist die Konfigurationsgruppe mit 3 Servern angelegt. Zum Anschauen einer log-Datei;
%
%\begin{listingsboxShell}[label={lst:X}]{myshell}{1.log-Inhalt}
%2016-12-19T14:58:11.637+0100 I CONTROL  [initandlisten] MongoDB starting :
%pid=25626 port=27017 dbpath=/data/rs1 64-bit host=vlfa.fritz.box
%// irrelevant
%2016-12-19T14:58:11.639+0100 I CONTROL  [initandlisten] options:
%{ net: { port: 27017 }, processManagement: { fork: true }, replication:
%{ oplogSizeMB: 64, replSet: "m101" }, storage: { dbPath: "/data/rs1",
%mmapv1: {smallFiles: true}}, systemLog: {destination: "file", path: "1.log"}}
%// irrelevant
%\end{listingsboxShell}

%Die Replikationsgruppe muss man zusätzlich initialisieren:
%
%\begin{listingsboxJavaScript}[label={lst:initReplica}]{myJS}{Skript zur Initialisierung der Replikationsgruppe}
%#init_replica.js
%config = { _id: "m101", members:[
%          { _id : 0, host : "localhost:27017"},
%          { _id : 1, host : "localhost:27018"},
%          { _id : 2, host : "localhost:27019"} ]
%};
%
%rs.initiate(config);
%rs.status();
%\end{listingsboxJavaScript}

Nach der erfolgreichen Skript-Ausführung veranschaulicht das Ergebnis (\textbf{Listing \ref{lst:result}}), dass eine Replikationsgruppe mit insgesamt 3 Mitgliedern angelegt worden ist.

%Configuring a replica set
%MongoDB shell version: 3.2.10
%connecting to: 127.0.0.1:27017/test
\begin{listingsboxShell}[label={lst:result}]{myjson}{Einer Replikationsgruppe wurde erzeugt}
{
	"_id" : "replSet",
	"members" : [
		{
			"_id" : 0,
			"host" : "localhost:27017"
		},
		{
			"_id" : 1,
			"host" : "localhost:27018"
		},
		{
			"_id" : 2,
			"host" : "localhost:27019"
		}
	]
}
{ "ok" : 1 }
\end{listingsboxShell}
%bye

Die Mitglieder der Replikationsruppe nehmen nun Kontakt miteinander auf und wählen den \textit{Primary}-Server aus. Beim Ausfall des \textit{Primary}-Servers wählen die \textit{Secondaries} untereinander entsprechend einen neuen \textit{Primary}-Server aus. Damit kann die Ausfallsicherheit des Servers erreicht.

Den Zustand der Replikationsgruppe ist möglich, mit \texttt{rs.status()} zu überprüfen. Listing \ref{lst:status} zeigt das entsprechende Resultat, welches beispielsweise zeigt, wer aktuell die Rolle des  \textit{Primary}-Servers übernimmt.

\begin{listingsboxShell}[label={lst:status}]{myjson}{Einer Replikationsgruppe wurde erzeugt}
{
	"set" : "replSet",
	...
	"syncingTo" : "localhost:27017",
	"members" : [
		{
			"_id" : 0,
			"name" : "localhost:27017",
			...
			"stateStr" : "PRIMARY",
			...
		},
		{
			"_id" : 1,
			"name" : "localhost:27018",
			...
			"stateStr" : "SECONDARY",
			...
			"syncingTo" : "localhost:27017"
		},
		{
			"_id" : 2,
			"name" : "localhost:27019",
			...
			"stateStr" : "SECONDARY",
			...
			"syncingTo" : "localhost:27018"
		}
	],
	"ok" : 1
}
\end{listingsboxShell}

Um sicher zu gehen, dass der Ausfallsicherheit korrekt funktioniert, kann der Ausfall des \textit{Primary}-Servers mit dem Befehl \texttt{rs.stepDown()} simuliert werden. Die Folge der Simulation führt dazu, dass alle Mitglieder der Replikationsgruppe untereinander einen neuen \textit{Primary}-Server auswählen. Listing \ref{lst:simulation} veranschaulich nach der erfolgreichen Simulation des \textit{Primary-}Serverausfalls das entsprechende Ergebnis.

\begin{listingsboxShell}[label={lst:simulation}]{myjson}{Das Ergebnis nach der Simulation des \textit{Primary-}Serverausfalls }

{
	"set" : "replSet",
	...
	"syncingTo" : "localhost:27019",
	"members" : [
		{
			"_id" : 0,
			"name" : "localhost:27017",
			...
			"stateStr" : "SECONDARY",
			...
			"syncingTo" : "localhost:27019"
		},
		{
			"_id" : 1,
			"name" : "localhost:27018",
			...
			"stateStr" : "SECONDARY",
			...
			"syncingTo" : "localhost:27019"
		},
		{
			"_id" : 2,
			"name" : "localhost:27019",
			...
			"stateStr" : "PRIMARY",
			...
		}
	],
	"ok" : 1
}
\end{listingsboxShell}

Nachdem die Replikationsgruppe angelegt und erfolgreich nach dem möglichen Serverausfall  des \textit{Primary-}Servers getestet worden ist, kann mithilfe des Java \mongo-Treibers die Replikationsgruppe für die Schreib- und Lesezugriffe verwendet werden. Listing \ref{lst:javaZugriff} veranschaulicht das Beispiel.

\begin{listingsboxJava}[label={lst:javaZugriff}]{myJava}{Initialisierung einer Replikationsgruppe}
public static void main (String[] args) throws InterruptedException {
        MongoClient client = new MongoClient(asList(
                new ServerAddress("localhost", 27017),
                new ServerAddress("localhost", 27018),
                new ServerAddress("localhost", 27019)));
                
                // weitere CRUD-Operationen
}
\end{listingsboxJava}

%\begin{listingsboxShell}[label={lst:X}]{myshell}{Simulation des Server-Ausfalls 'PRIMARY' über Shell}
%m101:PRIMARY> rs.stepDown()
%
%Result:
%
%2016-12-19T21:24:12.739+0100 I NETWORK  [thread1]
%trying reconnect to 127.0.0.1:27018 (127.0.0.1) failed
%2016-12-19T21:24:12.760+0100 I NETWORK  [thread1]
%reconnect 127.0.0.1:27018 (127.0.0.1) ok
%m101:SECONDARY> 
%\end{listingsboxShell}

Um die Sicherung der Zugehörigkeit der Mitglieder zu konkreter Replikationsgruppe festzustellen, kann der Code aus Listing \ref{lst:javaZugriff} entsprechend erweitert werden, Zeilen 6-8 in Listing \ref{lst:guarantee}.
\begin{listingsboxJava}[label={lst:guarantee}]{myJava}{Sicherung der Zugehörigkeit zu konkreter Replikationsgruppe}
 public static void main (String[] args) throws InterruptedException {
        MongoClient client = new MongoClient(asList(
                new ServerAddress("localhost", 27017),
                new ServerAddress("localhost", 27018),
                new ServerAddress("localhost", 27019)), 
                MongoClientOptions.builder()
                        .requiredReplicaSetName("replSet")
                        .build());
\end{listingsboxJava}

Um die Daten auf mehreren Servern zu verteilen, wird in dem Prototyp die horizontale Skalierung umgesetzt.

%\subsubsection{\colorbox{red}{Skalierung (Sharding)}}
\subsubsection{Skalierung (Sharding)}

Für die horizontale Skalierung wird entsprechend ein Skript geschrieben (\textbf{Anhang \ref{anhang}, Listings \ref{lst:createShards}, \ref{lst:createShards2} und \ref{lst:createShards3}}), um die Daten einer \textit{Collection} in \textit{Chunks} auf mehrere \textit{Shards} aufzuteilen. Nach der Skript-Ausführung werden insgesamt 3 \textit{Shards} erzeugt, mit je einer Replikationsgruppe inklusive 3 Server. Im Skript wurden zu den einzelnen Schritten die Kommentare passend hinzugefügt.

\subsection{Web-Server}
%\subsection{\colorbox{yellow}{Web-Server}}

%\begin{listingsboxJava}[label={lst:X}]{myJava}{}
%
%\end{listingsboxJava}
In der Spring-basierten Webanwendung muss der \textit{Spring Core Container}, in dem \textit{Beans} definiert sind und diese per \textit{Dependency Injection (DI)} zusammengebracht werden, über einen \texttt{ApplicationContext} erzeugt werden.
\begin{listingsboxJava}[label={lst:X}]{myJava}{Webanwendung starten}
// imports

@SpringBootApplication
public class Application {

    public static void main(String[] args) throws Exception {
        SpringApplication.run(Application.class, args);
    }
}
\end{listingsboxJava}
Die \texttt{@SpringBootApplication}-Annotation fasst insgesamt die drei Annotationen zusammen:
\begin{itemize}

\item \texttt{@Configuration} - deklariert eine Klasse als Konfigurationsklasse für Springs Java-basierende Konfiguration.
\item \texttt{@EnableAutoConfiguration} - aktiviert eine automatische Konfiguration durch Spring Boot.
\item \texttt{@ComponentScan} - scannt die weiteren per \texttt{@Controller-} oder \texttt{@Service}- annotierte Klassen, die über den \texttt{ApplicationContext} erzeugt werden.\footnote{Spring Boot, \url{http://www.torsten-horn.de/techdocs/Spring-Boot.html}, zugegriffen am 29. Januar 2017}

\end{itemize}

\subsubsection{Spring Core Container}

Spring stellt eine wichtige Annotation zur Verdrahtung der Komponenten. Diese ist die \textit{@Autowired}-Annotation. Diese Annotation funktioniert nicht nur auf Attributenebene  (Zeilen 5-6 in Listing \ref{lst:autoWired}) funktionieren, sondern auch auf Konstruktor- und Methodenebene. Sie lässt per Default nach \textit{typgleichen} Komponenten im \texttt{ApplicationContext} suchen und injizieren.

\begin{listingsboxJava}[label={lst:autoWired}]{myJava}{\texttt{@Autowired}-Annotation}
import org.springframework.beans.factory.annotation.Autowired;

public class PhotoAlbumController {
    
    @Autowired
    private PhotoAlbumService photoAlbumService;

    public PhotoAlbumController(PhotoAlbumService photoAlbumService) {
        this.photoAlbumService = photoAlbumService;
    }
    // ...
}
\end{listingsboxJava}

Die Klasse \texttt{PhotoAlbumController} bekommt einen \texttt{photoAlbumService} als Konstruktorargument typisiert als \texttt{PhotoAlbumService}-Interface. Das bedeutet, dass dem PhotoAlbumController nicht wichtig ist, zu welcher Art vom \texttt{PhotoAlbumService} er aufgefordert wird, solange die \texttt{PhotoAlbumServices} das \texttt{PhotoAlbumService}-Interface implementieren. Durch den Einsatz der \texttt{@Autowired}-Annotation wird eine passende \textit{Bean} automatisch injiziert, sobald diese \textit{Bean} das \texttt{PhotoAlbumService} implementiert und mit entsprechender Annotation versehen ist.

\begin{listingsboxJava}[label={lst:implement}]{myJava}{\texttt{@Component}-Annotation}
import org.springframework.stereotype.Component;

@Component
public class PhotoAlbumServiceImpl implements PhotoAlbumService {

	// Implementierung
}
\end{listingsboxJava}

Sollte Spring keine passende \textit{Bean} finden, dann geht das Autowiring schief. Für diesen Fall wird normalerweise eine \texttt{NullPointerException} geworfen. Um \texttt{NullPointerException} für so einen Fall umgehen zu können, bietet Spring eine optionale Autowiring-Konfiguration an, bei der ein \texttt{required}-Attribut auf \texttt{false} gesetzt wird.

\begin{listingsboxJava}[label={lst:requiredFalse}]{myJava}{Optionale Autowiring-Konfiguration}
import org.springframework.beans.factory.annotation.Autowired;

public class PhotoAlbumController {
    
    @Autowired(required=false)
    private PhotoAlbumService photoAlbumService;
    // ...
}
\end{listingsboxJava}

Als Ergebnis bleibt entweder das Attribut oder Parameter einfach \texttt{null}.
\subsubsection{Spring Web}
Ein Benutzer bekommt mit dem implementierten Prototyp die Möglichkeit, über verschiedene \textit{URL}s Fotoalben mit Fotos anzuzeigen, neue Fotoalben mit neuen Fotos anzulegen, bestehende zu modifizieren oder zu löschen. Die Technologie, in der die Aufgabe umgesetzt wird, ist \textit{REST}.

Die folgenden Beispiele zeigen, wie Spring Framework \textit{REST} implementiert.

\begin{listingsboxJava}[label={lst:postAndGet}]{myJava}{Beispiel für \textit{GET-}Methode}
// imports

@RestController
@RequestMapping(value = "/users/{userName}/photoAlben/")
public class PhotoAlbumController {
    
    @Autowired
    private PhotoAlbumService photoAlbumService;

    public PhotoAlbumController(PhotoAlbumService photoAlbumService) {
        this.photoAlbumService = photoAlbumService;
    }
    
    @RequestMapping(value = "createPhotoAlbumByUserName",
    							method = RequestMethod.POST)
    public boolean createPhotoAlbumByUserName(@PathVariable String userName,
    									@RequestBody PhotoAlbum photoAlbum) {
        return photoAlbumService.createPhotoAlbumByUserName(userName, photoAlbum);
    }
    
    @RequestMapping(path = "findAllPhotoAlbenByUserName",
    							method = RequestMethod.GET)
    public List<PhotoAlbum> findAllPhotoAlbenByUserName(
    								@PathVariable("userName") String userName) {
        return photoAlbumService.findAllPhotoAlbenByUserName(userName);
    }
    // ...
}
\end{listingsboxJava}


%\begin{listingsboxJava}[label={lst:X}]{myJava}{}
%// imports
%
%@RestController
%@MultipartConfig(fileSizeThreshold = 20971520)
%@RequestMapping(value = "/users/{userName}/{albumTitle}/photos/")
%public class PhotoController {
%
%    private PhotoService photoService;
%
%    @Autowired
%    public PhotoController(PhotoService photoService) {
%        this.photoService = photoService;
%    }
%
%    @RequestMapping(value = "savePhotoByAlbumTitleOfUser/",
%    						method = RequestMethod.POST)
%    public boolean savePhotoByAlbumTitleOfUser(
%            @PathVariable String userName,
%            @PathVariable String albumTitle,
%            @RequestParam("file") MultipartFile file) throws IOException {
%
%        boolean result;
%
%        if (!file.isEmpty()) {
%            try {
%                Photo photo = new Photo();
%                photo.setMultipartFile(file);
%                result = this.photoService.savePhotoByAlbumTitleOfUser(userName,
%                										albumTitle, photo);
%            } catch (Exception e) {
%                result = false;
%                System.out.println("failed to upload the file: " +
%                				file + " => " + e.getMessage());
%            }
%        } else {
%            result = false;
%            System.out.println("failed to upload the file: " +
%            				file + ", because the file was empty.");
%        }
%        return result;
%    }
%	// other methods
%}
%\end{listingsboxJava}




%%\subsection{Load Balancer}
%\subsection{\colorbox{red}{Load Balancer}}
%
%%\subsection{Web-Client}
%\subsection{\colorbox{red}{Web-Client}}

%Vorhanden ist, dass Frontend die Liste von Photos, dargestellt als List von bytesArrays (jeweils ein byteArray stellt ein Photo dar) bekommt und diese im Frontend anzeigt. Besser ist, nur die LIste von Photos-Ids zu bekommen und  Session in Frontend einschalten. Der User erhält dann nur einen Teil von Photos, falls gewünscht den weiteren Teil etc.

%\subsection{MongoDB mit Java}
%\subsubsection{\colorbox{red}{MongoDB mit Java}}
%
%\begin{listingsboxJava}[label={lst:conn}]{myJava}{Verbindungsaufbau}
%public static void main(String[] args) {
%
%	MongoClient mongoClient = new MongoClient("localhost", 27017);
%        MongoDatabase db = mongoClient.getDatabase("test");
%        MongoCollection<Document> collectionOfZips = db.getCollection("zips");
%        
%        // weitere CRUD-Operationen mit der ausgewählten Kollektion
%}
%\end{listingsboxJava}
%
%\begin{listingsboxJava}[label={lst:X}]{myJava}{Skript zur Initialisierung der Replikationsgruppe}
%public static void main (String[] args) throws InterruptedException {
%        MongoClient client = new MongoClient(asList(
%                new ServerAddress("localhost", 27017),
%                new ServerAddress("localhost", 27018),
%                new ServerAddress("localhost", 27019)));
%                
%                // weitere CRUD-Operationen
%}
%\end{listingsboxJava}
%
%\begin{listingsboxShell}[label={lst:X}]{myshell}{Simulation des Server-Ausfalls 'PRIMARY'}
%m101:PRIMARY> rs.stepDown()
%
%Result:
%
%2016-12-19T21:24:12.739+0100 I NETWORK  [thread1]
%trying reconnect to 127.0.0.1:27018 (127.0.0.1) failed
%2016-12-19T21:24:12.760+0100 I NETWORK  [thread1]
%reconnect 127.0.0.1:27018 (127.0.0.1) ok
%m101:SECONDARY> 
%\end{listingsboxShell}
%
%Der aktuelle MongoDB Java Treiber ist in Version 3.4.0 verfügbar und kann bequem als Maven Dependency geladen werden.
% 
%\begin{listingsboxJava}[label={lst:mongoJDriver}]{myxml}{MongoDB Java Treiber als Maven Dependency, Version 3.4.0}
%<dependency>
%        <groupId>org.mongodb</groupId>
%        <artifactId>mongo-java-driver</artifactId>
%        <version>3.4.0</version>
%</dependency>
%\end{listingsboxJava}
%
%Um die Sicherung der Zugehörigkeit der Mitglieder zu konkreter Replikationsgruppe festzustellen, Zeilen 6-8...
%\begin{listingsboxJava}[label={lst:guarantee}]{myJava}{Sicherung der Zugehörigkeit zu konkreter Replikationsgruppe}
% public static void main (String[] args) throws InterruptedException {
%        MongoClient client = new MongoClient(asList(
%                new ServerAddress("localhost", 27017),
%                new ServerAddress("localhost", 27018),
%                new ServerAddress("localhost", 27019)), 
%                MongoClientOptions.builder()
%                        .requiredReplicaSetName("m101")
%                        .build());
%\end{listingsboxJava}



